{"ast":null,"code":"'use strict';\n\nconst utils = require('./utils');\n\nfunction getRequestOpts(self, requestArgs, spec, overrideData) {\n  // Extract spec values with defaults.\n  const requestMethod = (spec.method || 'GET').toUpperCase();\n  const urlParams = spec.urlParams || [];\n\n  const encode = spec.encode || (data => data);\n\n  const isUsingFullPath = !!spec.fullPath;\n  const commandPath = utils.makeURLInterpolator(isUsingFullPath ? spec.fullPath : spec.path || ''); // When using fullPath, we ignore the resource path as it should already be\n  // fully qualified.\n\n  const path = isUsingFullPath ? spec.fullPath : self.createResourcePathWithSymbols(spec.path); // Don't mutate args externally.\n\n  const args = [].slice.call(requestArgs); // Generate and validate url params.\n\n  const urlData = urlParams.reduce((urlData, param) => {\n    const arg = args.shift();\n\n    if (typeof arg !== 'string') {\n      throw new Error(`Stripe: Argument \"${param}\" must be a string, but got: ${arg} (on API request to \\`${requestMethod} ${path}\\`)`);\n    }\n\n    urlData[param] = arg;\n    return urlData;\n  }, {}); // Pull request data and options (headers, auth) from args.\n\n  const dataFromArgs = utils.getDataFromArgs(args);\n  const data = encode(Object.assign({}, dataFromArgs, overrideData));\n  const options = utils.getOptionsFromArgs(args);\n  const host = options.host || spec.host;\n  const streaming = !!spec.streaming; // Validate that there are no more args.\n\n  if (args.filter(x => x != null).length) {\n    throw new Error(`Stripe: Unknown arguments (${args}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options. (on API request to ${requestMethod} \\`${path}\\`)`);\n  } // When using full path, we can just invoke the URL interpolator directly\n  // as we don't need to use the resource to create a full path.\n\n\n  const requestPath = isUsingFullPath ? commandPath(urlData) : self.createFullPath(commandPath, urlData);\n  const headers = Object.assign(options.headers, spec.headers);\n\n  if (spec.validator) {\n    spec.validator(data, {\n      headers\n    });\n  }\n\n  const dataInQuery = spec.method === 'GET' || spec.method === 'DELETE';\n  const bodyData = dataInQuery ? {} : data;\n  const queryData = dataInQuery ? data : {};\n  return {\n    requestMethod,\n    requestPath,\n    bodyData,\n    queryData,\n    auth: options.auth,\n    headers,\n    host,\n    streaming,\n    settings: options.settings\n  };\n}\n\nfunction makeRequest(self, requestArgs, spec, overrideData) {\n  return new Promise((resolve, reject) => {\n    let opts;\n\n    try {\n      opts = getRequestOpts(self, requestArgs, spec, overrideData);\n    } catch (err) {\n      reject(err);\n      return;\n    }\n\n    function requestCallback(err, response) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(spec.transformResponseData ? spec.transformResponseData(response) : response);\n      }\n    }\n\n    const emptyQuery = Object.keys(opts.queryData).length === 0;\n    const path = [opts.requestPath, emptyQuery ? '' : '?', utils.stringifyRequestData(opts.queryData)].join('');\n    const {\n      headers,\n      settings\n    } = opts;\n\n    self._request(opts.requestMethod, opts.host, path, opts.bodyData, opts.auth, {\n      headers,\n      settings,\n      streaming: opts.streaming\n    }, requestCallback);\n  });\n}\n\nmodule.exports = makeRequest;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nconst {\n  HttpClient,\n  HttpClientResponse\n} = require('./HttpClient');\n/**\n * HTTP client which uses a `fetch` function to issue requests.\n *\n * By default relies on the global `fetch` function, but an optional function\n * can be passed in. If passing in a function, it is expected to match the Web\n * Fetch API. As an example, this could be the function provided by the\n * node-fetch package (https://github.com/node-fetch/node-fetch).\n */\n\n\nclass FetchHttpClient extends HttpClient {\n  constructor(fetchFn) {\n    super();\n    this._fetchFn = fetchFn;\n  }\n  /** @override. */\n\n\n  getClientName() {\n    return 'fetch';\n  }\n\n  makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n    const isInsecureConnection = protocol === 'http';\n    const url = new URL(path, `${isInsecureConnection ? 'http' : 'https'}://${host}`);\n    url.port = port;\n    const fetchFn = this._fetchFn || fetch;\n    const fetchPromise = fetchFn(url.toString(), {\n      method,\n      headers,\n      body: requestData || undefined\n    }); // The Fetch API does not support passing in a timeout natively, so a\n    // timeout promise is constructed to race against the fetch and preempt the\n    // request, simulating a timeout.\n    //\n    // This timeout behavior differs from Node:\n    // - Fetch uses a single timeout for the entire length of the request.\n    // - Node is more fine-grained and resets the timeout after each stage of\n    //   the request.\n    //\n    // As an example, if the timeout is set to 30s and the connection takes 20s\n    // to be established followed by 20s for the body, Fetch would timeout but\n    // Node would not. The more fine-grained timeout cannot be implemented with\n    // fetch.\n\n    let pendingTimeoutId;\n    const timeoutPromise = new Promise((_, reject) => {\n      pendingTimeoutId = setTimeout(() => {\n        pendingTimeoutId = null;\n        reject(HttpClient.makeTimeoutError());\n      }, timeout);\n    });\n    return Promise.race([fetchPromise, timeoutPromise]).then(res => {\n      return new FetchHttpClientResponse(res);\n    }).finally(() => {\n      if (pendingTimeoutId) {\n        clearTimeout(pendingTimeoutId);\n      }\n    });\n  }\n\n}\n\nclass FetchHttpClientResponse extends HttpClientResponse {\n  constructor(res) {\n    super(res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));\n    this._res = res;\n  }\n\n  getRawResponse() {\n    return this._res;\n  }\n\n  toStream(streamCompleteCallback) {\n    // Unfortunately `fetch` does not have event handlers for when the stream is\n    // completely read. We therefore invoke the streamCompleteCallback right\n    // away. This callback emits a response event with metadata and completes\n    // metrics, so it's ok to do this without waiting for the stream to be\n    // completely read.\n    streamCompleteCallback(); // Fetch's `body` property is expected to be a readable stream of the body.\n\n    return this._res.body;\n  }\n\n  toJSON() {\n    return this._res.json();\n  }\n\n  static _transformHeadersToObject(headers) {\n    // Fetch uses a Headers instance so this must be converted to a barebones\n    // JS object to meet the HttpClient interface.\n    const headersObj = {};\n\n    for (const entry of headers) {\n      if (!Array.isArray(entry) || entry.length != 2) {\n        throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');\n      }\n\n      headersObj[entry[0]] = entry[1];\n    }\n\n    return headersObj;\n  }\n\n}\n\nmodule.exports = {\n  FetchHttpClient,\n  FetchHttpClientResponse\n};","map":null,"metadata":{},"sourceType":"script"}
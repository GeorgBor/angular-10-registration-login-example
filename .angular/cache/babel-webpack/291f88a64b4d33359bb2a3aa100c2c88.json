{"ast":null,"code":"'use strict';\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst {\n  HttpClient,\n  HttpClientResponse\n} = require('./HttpClient');\n\nconst defaultHttpAgent = new http.Agent({\n  keepAlive: true\n});\nconst defaultHttpsAgent = new https.Agent({\n  keepAlive: true\n});\n/**\n * HTTP client which uses the Node `http` and `https` packages to issue\n * requests.`\n */\n\nclass NodeHttpClient extends HttpClient {\n  constructor(agent) {\n    super();\n    this._agent = agent;\n  }\n  /** @override. */\n\n\n  getClientName() {\n    return 'node';\n  }\n\n  makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n    const isInsecureConnection = protocol === 'http';\n    let agent = this._agent;\n\n    if (!agent) {\n      agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;\n    }\n\n    const requestPromise = new Promise((resolve, reject) => {\n      const req = (isInsecureConnection ? http : https).request({\n        host: host,\n        port: port,\n        path,\n        method,\n        agent,\n        headers,\n        ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5'\n      });\n      req.setTimeout(timeout, () => {\n        req.destroy(HttpClient.makeTimeoutError());\n      });\n      req.on('response', res => {\n        resolve(new NodeHttpClientResponse(res));\n      });\n      req.on('error', error => {\n        reject(error);\n      });\n      req.once('socket', socket => {\n        if (socket.connecting) {\n          socket.once(isInsecureConnection ? 'connect' : 'secureConnect', () => {\n            // Send payload; we're safe:\n            req.write(requestData);\n            req.end();\n          });\n        } else {\n          // we're already connected\n          req.write(requestData);\n          req.end();\n        }\n      });\n    });\n    return requestPromise;\n  }\n\n}\n\nclass NodeHttpClientResponse extends HttpClientResponse {\n  constructor(res) {\n    super(res.statusCode, res.headers || {});\n    this._res = res;\n  }\n\n  getRawResponse() {\n    return this._res;\n  }\n\n  toStream(streamCompleteCallback) {\n    // The raw response is itself the stream, so we just return that. To be\n    // backwards compatible, we should invoke the streamCompleteCallback only\n    // once the stream has been fully consumed.\n    this._res.once('end', () => streamCompleteCallback());\n\n    return this._res;\n  }\n\n  toJSON() {\n    return new Promise((resolve, reject) => {\n      let response = '';\n\n      this._res.setEncoding('utf8');\n\n      this._res.on('data', chunk => {\n        response += chunk;\n      });\n\n      this._res.once('end', () => {\n        try {\n          resolve(JSON.parse(response));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = {\n  NodeHttpClient,\n  NodeHttpClientResponse\n};","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"E:\\\\gitHubRepo\\\\Software-Engineering\\\\angular10-registration-login-example\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst utils = require('./utils');\n\nconst {\n  StripeError,\n  StripeSignatureVerificationError\n} = require('./Error');\n\nconst Webhook = {\n  DEFAULT_TOLERANCE: 300,\n\n  // 5 minutes\n  constructEvent(payload, header, secret, tolerance, cryptoProvider) {\n    this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n    const jsonPayload = JSON.parse(payload);\n    return jsonPayload;\n  },\n\n  constructEventAsync(payload, header, secret, tolerance, cryptoProvider) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n      const jsonPayload = JSON.parse(payload);\n      return jsonPayload;\n    })();\n  },\n\n  /**\n   * Generates a header to be used for webhook mocking\n   *\n   * @typedef {object} opts\n   * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n   * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n   * @property {string} secret - Stripe webhook secret 'whsec_...'\n   * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n   * @property {string} signature - Computed webhook signature\n   * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.\n   */\n  generateTestHeaderString: function (opts) {\n    if (!opts) {\n      throw new StripeError({\n        message: 'Options are required'\n      });\n    }\n\n    opts.timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n    opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;\n    opts.cryptoProvider = opts.cryptoProvider || getNodeCryptoProvider();\n    opts.signature = opts.signature || opts.cryptoProvider.computeHMACSignature(opts.timestamp + '.' + opts.payload, opts.secret);\n    const generatedHeader = ['t=' + opts.timestamp, opts.scheme + '=' + opts.signature].join(',');\n    return generatedHeader;\n  }\n};\nconst signature = {\n  EXPECTED_SCHEME: 'v1',\n\n  verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n    const {\n      decodedHeader: header,\n      decodedPayload: payload,\n      details\n    } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n    cryptoProvider = cryptoProvider || getNodeCryptoProvider();\n    const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);\n    validateComputedSignature(payload, header, details, expectedSignature, tolerance);\n    return true;\n  },\n\n  verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        decodedHeader: header,\n        decodedPayload: payload,\n        details\n      } = parseEventDetails(encodedPayload, encodedHeader, _this2.EXPECTED_SCHEME);\n      cryptoProvider = cryptoProvider || getNodeCryptoProvider();\n      const expectedSignature = yield cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);\n      return validateComputedSignature(payload, header, details, expectedSignature, tolerance);\n    })();\n  }\n\n};\n\nfunction makeHMACContent(payload, details) {\n  return `${details.timestamp}.${payload}`;\n}\n\nfunction parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {\n  const decodedPayload = Buffer.isBuffer(encodedPayload) ? encodedPayload.toString('utf8') : encodedPayload; // Express's type for `Request#headers` is `string | []string`\n  // which is because the `set-cookie` header is an array,\n  // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)\n  // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)\n\n  if (Array.isArray(encodedHeader)) {\n    throw new Error('Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.');\n  }\n\n  const decodedHeader = Buffer.isBuffer(encodedHeader) ? encodedHeader.toString('utf8') : encodedHeader;\n  const details = parseHeader(decodedHeader, expectedScheme);\n\n  if (!details || details.timestamp === -1) {\n    throw new StripeSignatureVerificationError({\n      message: 'Unable to extract timestamp and signatures from header',\n      detail: {\n        decodedHeader,\n        decodedPayload\n      }\n    });\n  }\n\n  if (!details.signatures.length) {\n    throw new StripeSignatureVerificationError({\n      message: 'No signatures found with expected scheme',\n      detail: {\n        decodedHeader,\n        decodedPayload\n      }\n    });\n  }\n\n  return {\n    decodedPayload,\n    decodedHeader,\n    details\n  };\n}\n\nfunction validateComputedSignature(payload, header, details, expectedSignature, tolerance) {\n  const signatureFound = !!details.signatures.filter(utils.secureCompare.bind(utils, expectedSignature)).length;\n\n  if (!signatureFound) {\n    throw new StripeSignatureVerificationError({\n      message: 'No signatures found matching the expected signature for payload.' + ' Are you passing the raw request body you received from Stripe?' + ' https://github.com/stripe/stripe-node#webhook-signing',\n      detail: {\n        header,\n        payload\n      }\n    });\n  }\n\n  const timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n\n  if (tolerance > 0 && timestampAge > tolerance) {\n    throw new StripeSignatureVerificationError({\n      message: 'Timestamp outside the tolerance zone',\n      detail: {\n        header,\n        payload\n      }\n    });\n  }\n\n  return true;\n}\n\nfunction parseHeader(header, scheme) {\n  if (typeof header !== 'string') {\n    return null;\n  }\n\n  return header.split(',').reduce((accum, item) => {\n    const kv = item.split('=');\n\n    if (kv[0] === 't') {\n      accum.timestamp = kv[1];\n    }\n\n    if (kv[0] === scheme) {\n      accum.signatures.push(kv[1]);\n    }\n\n    return accum;\n  }, {\n    timestamp: -1,\n    signatures: []\n  });\n}\n\nlet webhooksNodeCryptoProviderInstance = null;\n/**\n * Lazily instantiate a NodeCryptoProvider instance. This is a stateless object\n * so a singleton can be used here.\n */\n\nfunction getNodeCryptoProvider() {\n  if (!webhooksNodeCryptoProviderInstance) {\n    const NodeCryptoProvider = require('./crypto/NodeCryptoProvider');\n\n    webhooksNodeCryptoProviderInstance = new NodeCryptoProvider();\n  }\n\n  return webhooksNodeCryptoProviderInstance;\n}\n\nWebhook.signature = signature;\nmodule.exports = Webhook;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"E:\\\\gitHubRepo\\\\Software-Engineering\\\\angular10-registration-login-example\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst CryptoProvider = require('./CryptoProvider');\n/**\n * `CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.\n *\n * This only supports asynchronous operations.\n */\n\n\nclass SubtleCryptoProvider extends CryptoProvider {\n  constructor(subtleCrypto) {\n    super(); // If no subtle crypto is interface, default to the global namespace. This\n    // is to allow custom interfaces (eg. using the Node webcrypto interface in\n    // tests).\n\n    this.subtleCrypto = subtleCrypto || crypto.subtle;\n  }\n  /** @override */\n\n\n  computeHMACSignature(payload, secret) {\n    throw new Error('SubtleCryptoProvider cannot be used in a synchronous context.');\n  }\n  /** @override */\n\n\n  computeHMACSignatureAsync(payload, secret) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const encoder = new TextEncoder('utf-8');\n      const key = yield _this.subtleCrypto.importKey('raw', encoder.encode(secret), {\n        name: 'HMAC',\n        hash: {\n          name: 'SHA-256'\n        }\n      }, false, ['sign']);\n      const signatureBuffer = yield _this.subtleCrypto.sign('hmac', key, encoder.encode(payload)); // crypto.subtle returns the signature in base64 format. This must be\n      // encoded in hex to match the CryptoProvider contract. We map each byte in\n      // the buffer to its corresponding hex octet and then combine into a string.\n\n      const signatureBytes = new Uint8Array(signatureBuffer);\n      const signatureHexCodes = new Array(signatureBytes.length);\n\n      for (let i = 0; i < signatureBytes.length; i++) {\n        signatureHexCodes[i] = byteHexMapping[signatureBytes[i]];\n      }\n\n      return signatureHexCodes.join('');\n    })();\n  }\n\n} // Cached mapping of byte to hex representation. We do this once to avoid re-\n// computing every time we need to convert the result of a signature to hex.\n\n\nconst byteHexMapping = new Array(256);\n\nfor (let i = 0; i < byteHexMapping.length; i++) {\n  byteHexMapping[i] = i.toString(16).padStart(2, '0');\n}\n\nmodule.exports = SubtleCryptoProvider;","map":null,"metadata":{},"sourceType":"script"}